#### 线程库封装

---

C++11中 提供了原生的线程类 来提供更方便的线程创建和使用

这里自己从零, 用linux的capi，手写了一套线程框架，功能也并不复杂，如下：

首先有一个Thread类,包含以下几个成员变量 : 

- m_id pid_t 线程id
- m_thread Pthread_t 线程id

注意两者的区别

| pthread_t | 进程内唯一的，不同进程内可能相同。                           |
| --------- | ------------------------------------------------------------ |
| pid_t     | 全局唯一，不同进程内也不相同。而且是采用递增轮回法分配，短时间内启动多个线程也会具有不同的线程id。 |

- m_cb 线程执行函数 std::function<void()>类型

- m_name 线程名字

结构并不复杂 后面可能会加入信号量之类的.

成员函数如下：

- 构造函数 参数为一个执行函数 一个名字

  在构造函数内 调用pthread的接口pthread_create函数来创建一个线程

  该函数有四个参数 一个指向线程表示符的指针 也就是传入成员变量m_thread的地址

  第二个参数用来设置线程的属性

  第三个是执行函数的起始地址

  第四个是执行函数的参数

- Getthis 函数 返回一个指向当前Thread变量的指针

- getname 获取线程名

- setname 设置线程名

- join函数

  调用了pthread中pthread_join函数

  参数 ：thread: 线程[标识符](https://baike.baidu.com/item/标识符/7105638)，即线程ID，标识唯一线程。retval: 用户定义的指针，用来存储被等待线程的返回值。

  调用这个函数之后 线程就会启动 主线程就会阻塞

- run函数 

  对m_cb线程执行函数的封装 在pthread_create函数中传入的就是run的起始地址